#!/bin/bash
#
# Copyright (c) 2017 Harry YJ Jhou
#
# This software is distributed under the terms of the
# Apache License.
#
# Moxa led control utility
#

declare -A SGN_PATH
declare -A PROG_PATH

usage(){
	echo -e "Usage:"
	echo -e "		\
$0 <-s #sgn_group |-p #prog_group > <-i #led_index |-r #data > "
	echo -e "OPTIONS:"
	echo -e "		-s <#led_group>"
	echo -e "				Control signal led"
	echo -e "		-p <#led_group>"
	echo -e "				Control programmable led"
	echo -e "		-i <#led_index> [on|off|blink]"
	echo -e "				Switch #led_index led on/off/blink"
	echo -e "		-r <#data>"
	echo -e "				Switch #led_group leds on/off/blink by raw data"
	echo -e "				data 0 --> led off"
	echo -e "				data 1 --> led on"
	echo -e "				data b --> led blink"
	echo -e "		--all-signal <on|off|blink>"
	echo -e "				Switch all signal leds on/off/blink"
	echo -e "		--all-programmable <on|off|blink>"
	echo -e "				Switch all programmable leds on/off/blink"
	echo -e ""
	echo -e "Example:"
	echo -e "		Turn on 'Signal' led GROUP 2 INDEX 3"
	echo -e "		# mx-led-ctl -s 2 -i 3 on"
	echo -e ""
	echo -e "		Turn off 'Programmable' led GROUP 2 INDEX 3"
	echo -e "		# mx-led-ctl -p 2 -i 3 off"
	echo -e ""
	echo -e "		Turn on/off 'Signal' led GROUP 2 by raw data"
	echo -e "		Index 1 --> off"
	echo -e "		Index 2 --> on"
	echo -e "		Index 3 --> off"
	echo -e "		Index 4 --> off"
	echo -e "		# mx-led-ctl -s 2 -r 0100"

	exit 99
}

check_parameters(){
	[ x"$SIGNAL_FUNC" == x"" ] && usage
	[ x"$INDEX_FUNC" == x"" ] && usage
}

# set signal or programmable led
# set GROUP number
set_led_func(){
	local signal_func="$1"
	local group="$2"

	if [ x"$SIGNAL_FUNC" == x"" ]; then
		SIGNAL_FUNC="$signal_func"
		GROUP="$group"
	else
		usage
	fi
}

# set index or raw method
# set on/off data
set_index_func(){
	local index_func="$1"
	local data="$2"
	local switch="$3"

	if [ x"$INDEX_FUNC" == x"" ]; then
		INDEX_FUNC="$index_func"
		DATA="$data"
		if [ x"$INDEX_FUNC" == x"index" ]; then
			if [ x"$switch" == x"on" ]; then
				SWITCH="$ON_VALUE"
			elif [ x"$switch" == x"off" ]; then
				SWITCH="$OFF_VALUE"
			elif [ x"$switch" == x"blink" ]; then
				SWITCH="$HEARTBEAT_VALUE"
			else
				usage
			fi
		fi
	else
		usage
	fi
}

set_led_signal(){
	local path="$1"
	local value="$2"

	[ ! -d ${path} ] && return

	if [ x"$value" == x"$ON_VALUE" ]; then
		echo $OFF_VALUE > ${path}/${BRIGHTNESS}
		echo $value > ${path}/${BRIGHTNESS}
	elif [ x"$value" == x"$OFF_VALUE" ]; then
		echo $value > ${path}/${BRIGHTNESS}
	elif [ x"$value" == x"b" ] || [ x"$SWITCH" == x"$HEARTBEAT_VALUE" ]; then
		echo $HEARTBEAT_VALUE > ${path}/${TRIGGER}
	else
		usage
	fi
}

set_all_led(){
	local signal_func="$1"
	local switch="$2"

	set_index_func index 0 $2

	if [ x"$signal_func" == x"signal" ]; then
		# signal led
		for (( i=1 ; i<="$MAX_SGN_GROUP" ; i++ ))
		do
			for (( j=1 ; j<="$MAX_SGN_INDEX" ; j++ ))
			do
				set_led_signal ${SGN_PATH[$i,$j]} $SWITCH
			done
		done
	elif [ x"$signal_func" == x"programmable" ]; then
		# programmable led
		for (( i=1 ; i<="$MAX_PROG_GROUP" ; i++ ))
		do
			for (( j=1 ; j<="$MAX_PROG_INDEX" ; j++ ))
			do
				set_led_signal ${PROG_PATH[$i,$j]} $SWITCH
			done
		done
	fi
}

# DEBUG function
__debug__(){
	#echo SIGNAL_FUNC=$SIGNAL_FUNC
	#echo INDEX_FUNC=$INDEX_FUNC
	#echo DATA=$DATA
	#echo SWITCH=$SWITCH
	#echo GROUP=$GROUP

	echo CFG_VERSION=$CFG_VERSION
	echo MAX_SGN_GROUP=$MAX_SGN_GROUP
	echo MAX_SGN_INDEX=$MAX_SGN_INDEX
	echo MAX_PROG_GROUP=$MAX_PROG_GROUP
	echo MAX_PROG_INDEX=$MAX_PROG_INDEX
	echo ON_VALUE=$ON_VALUE
	echo OFF_VALUE=$OFF_VALUE
	echo HEARTBEAT_VALUE=$HEARTBEAT_VALUE
	echo LED_PATH=$LED_PATH
	echo BRIGHTNESS=$BRIGHTNESS
	echo TRIGGER=$TRIGGER

}

load_config()
{
	RAW_CONFIG_DATA="$(awk -f $JSON_AWK_CFG_FILE $CFG_FILE)"
	RAW_CONFIG_DATA=$(sed 's/\[\"//g' <<< $RAW_CONFIG_DATA)
	RAW_CONFIG_DATA=$(sed 's/[[:space:]]//g' <<< $RAW_CONFIG_DATA)
	RAW_CONFIG_DATA=$(sed 's/\"\]\"/=\"/g' <<< $RAW_CONFIG_DATA)
	RAW_CONFIG_DATA=$(sed 's/\",/\[/g' <<< $RAW_CONFIG_DATA)
	RAW_CONFIG_DATA=$(sed 's/\]\"/\]=\"/g' <<< $RAW_CONFIG_DATA)
	eval $RAW_CONFIG_DATA

	# load SGN_PATH
	for (( i=${MAX_SGN_GROUP}; i>0 ; i-- ))
	do
		for (( j=${MAX_SGN_INDEX}; j>0 ; j-- ))
		do
			SGN_PATH[$i,$j]="${LED_PATH}${SGN_PATH[$((i-1)),$((j-1))]}"
		done
	done

	# load PROG_PATH
	for (( i=${MAX_PROG_GROUP}; i>0 ; i-- ))
	do
		for (( j=${MAX_PROG_INDEX}; j>0 ; j-- ))
		do
			PROG_PATH[$i,$j]="${LED_PATH}${PROG_PATH[$((i-1)),$((j-1))]}"
		done
	done
	return
}

load_config_by_jq()
{
	CFG_VERSION="$(jq ".CFG_VERSION" $CFG_FILE --raw-output)"
	MAX_SGN_GROUP="$(jq ".MAX_SGN_GROUP" $CFG_FILE --raw-output)"
	MAX_SGN_INDEX="$(jq ".MAX_SGN_INDEX" $CFG_FILE --raw-output)"

	MAX_PROG_GROUP="$(jq ".MAX_PROG_GROUP" $CFG_FILE --raw-output)"
	MAX_PROG_INDEX="$(jq ".MAX_PROG_INDEX" $CFG_FILE --raw-output)"

	ON_VALUE="$(jq ".ON_VALUE" $CFG_FILE --raw-output)"
	OFF_VALUE="$(jq ".OFF_VALUE" $CFG_FILE --raw-output)"
	HEARTBEAT_VALUE="$(jq ".HEARTBEAT_VALUE" $CFG_FILE --raw-output)"

	LED_PATH="$(jq ".LED_PATH" $CFG_FILE --raw-output)"
	BRIGHTNESS="$(jq ".BRIGHTNESS" $CFG_FILE --raw-output)"
	TRIGGER="$(jq ".TRIGGER" $CFG_FILE --raw-output)"

	# load SGN_PATH
	for (( i=0; i<${MAX_SGN_GROUP} ; i++ ))
	do
		for (( j=0; j<${MAX_SGN_INDEX} ; j++ ))
		do
			SGN_PATH[$((i+1)),$((j+1))]="${LED_PATH}$(jq ".SGN_PATH[$i][$j]" $CFG_FILE --raw-output)"
		done
	done

	# load PROG_PATH
	for (( i=0; i<${MAX_PROG_GROUP} ; i++ ))
	do
		for (( j=0; j<${MAX_PROG_INDEX} ; j++ ))
		do
			PROG_PATH[$((i+1)),$((j+1))]="${LED_PATH}$(jq ".PROG_PATH[$i][$j]" $CFG_FILE --raw-output)"
		done
	done

}

# Initial function
init(){
	# Check config file
	CFG_FILE="/etc/moxa-configs/moxa-led-control.json"
	JSON_AWK_CFG_FILE="/etc/moxa-configs/JSON.awk"
	if [ -f "$CFG_FILE" ]; then
		load_config
	else
		echo "Error: product config not found."
		exit 2
	fi
}

# Main function
main(){
	# Check options
	if [ x"$INDEX_FUNC" == x"" ] || [ x"$SIGNAL_FUNC" == x"" ] ; then
		usage
	fi

	if [ x"$INDEX_FUNC" == x"index" ]; then
		# INDEX_FUNC=index, SIGNAL_FUNC=signal
		if [ x"$SIGNAL_FUNC" == x"signal" -a \
			x"${SGN_PATH[$GROUP,$DATA]}" != x"" ]; then
			set_led_signal ${SGN_PATH[$GROUP,$DATA]} $SWITCH
		# INDEX_FUNC=index, SIGNAL_FUNC=programmable
		elif [ x"$SIGNAL_FUNC" == x"programmable" -a \
				x"${PROG_PATH[$GROUP,$DATA]}" != x"" ]; then
			set_led_signal ${PROG_PATH[$GROUP,$DATA]} $SWITCH
		fi
	elif [ x"$INDEX_FUNC" == x"raw" ]; then
		# Check data
		for (( i=1 ; i<=${#DATA} ; i++ ))
		do
			if [ x"${DATA:$((i-1)):1}" != x"0" ] && \
			   [ x"${DATA:$((i-1)):1}" != x"1" ] && \
			   [ x"${DATA:$((i-1)):1}" != x"b" ] ;then
				usage
			fi
		done
		# INDEX_FUNC=raw, SIGNAL_FUNC=signal
		if [ x"$SIGNAL_FUNC" == x"signal" ]; then
			for (( i=1 ; i<=${#DATA} ; i++ ))
			do
				set_led_signal ${SGN_PATH[$GROUP,$i]} ${DATA:$((i-1)):1}
			done
		# INDEX_FUNC=raw, SIGNAL_FUNC=programmabel
		elif [ x"$SIGNAL_FUNC" == x"programmable" ]; then
			for (( i=1 ; i<=${#DATA} ; i++ ))
			do
				set_led_signal ${PROG_PATH[$GROUP,$i]} ${DATA:$((i-1)):1}
			done
		fi

	fi
}

init

# Read parameters
while [ x"$1" != x"" ]
do
	case "$1" in
		-s|--signal)
			set_led_func signal $2
			shift 2
			;;
		-p|--programmable)
			set_led_func programmable $2
			shift 2
			;;
		-i|--index)
			set_index_func index $2 $3
			shift 3
			;;
		-r|--raw)
			set_index_func raw $2
			shift 2
			;;
		--all-signal)
			set_all_led signal $2
			shift 2
			exit 0
			;;
		--all-programmable)
			set_all_led programmable $2
			shift 2
			exit 0
			;;
		-v|--version)
			echo "mx-led-ctl $VERSION"
			exit 0
			;;
		*)
			usage
			break
			;;
	esac
done

main
